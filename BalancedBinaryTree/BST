#include <iostream>
#include <math.h>
#include <vector>
using namespace std;

class node{
  public:
    int value;
    int height;
    node* left;
    node* right;
    node(){
      value = 0;
      height = 0;
      left = NULL;
      right = NULL;
    }
};

class Tree{
  public:
    node* root;

  Tree(){
    root = NULL;
  }
  node* search(int value){
    if(root==NULL){
      cout<< "There is nothing in the tree" <<endl;
    }else{
      node*leaf = root;
      while(leaf->left!=NULL||leaf->right!=NULL){
        if(leaf->value==value){
          return leaf;
        }else if(leaf->value <value){
          if(leaf->right!=NULL){
            leaf = leaf->right;
          }else{
            cout<< "no Such value on the right"<< endl;
            break;
          }
        }else if(leaf->value >value){
          if(leaf->left!=NULL){
            leaf = leaf->left;
          }else{
            cout<< "no Such value on the left"<< endl;
            break;
          }
        }else if(leaf==NULL){
          cout<<"No Such Value"<<endl;
          break;
        }
      }if(leaf->value==value){
          return leaf;
      }else{
        cout<<"No Such Value"<<endl;
      }
    }
    return NULL;
  }
  void insert(int value){
    if(root==NULL){
      root = new node;
      root->value = value;
      root->height = 0;
      return;
    }else{
      node* pointer;
      pointer = root;
      
      while(pointer->left!=NULL || pointer->right!=NULL){
        if(pointer->value < value){
          if(pointer->right==NULL){
            pointer->right = new node;
            pointer->right->value = value;
            updateHeight(root);
            bool Balanced = true;
        node *first = searchParent(pointer->right, value);
        
        while(first !=root){
          Balanced = ifBalanced(first);
          if(Balanced==false){
            break;
          }first = searchParent(first, first->value);
        }


        //cases where first ends up in a node different from root;
        while(ifBalanced(first)==false){
            node* pursuer = first;
            node* previous = searchParent(pursuer, pursuer->value);
            node* detector;
            int drh;
            int dlh;
            if(pursuer->left==NULL){
                dlh = -1;
            }else{
                dlh= pursuer->left->height;
            }
            if(pursuer->right==NULL){
                drh = -1;
            }else{
                drh= pursuer->right->height;
            }
            if(drh>dlh){
              detector = pursuer->right;
            }else{
              detector = pursuer->left;
            }
              
              int temp = root->value;
              int pr, pl, dr, dl;
              if(pursuer->right==NULL){
                pr=-1;
              }else{
                pr = pursuer->right->height;
              }
              if(pursuer->left==NULL){
                pl=-1;
              }else{
                pl= pursuer->left->height;
              }
              if(detector->right==NULL){
                dr=-1;
              }else{
                dr = detector->right->height;
              }
              if(detector->left==NULL){
                dl=-1;
              }else{
                dl= detector->left->height;
              }

              if(pl>pr){
                if(dr>dl){
                  rightRotation(detector, pursuer);
                  leftRotation(pursuer, previous);
                }else{
                  leftRotation(pursuer, previous);
                }
              }else{
                if(dl>dr){
                  leftRotation(detector, pursuer);
                  rightRotation(pursuer, previous);
                }else{
                  rightRotation(pursuer, previous);
                }
              }
            if(first->value == temp){
              break;
            }else{
              first = searchParent(first, first->value);
            }
        }
        return;
        }else{
            pointer = pointer->right;
        }
        }else if(pointer->value >value){
          if(pointer->left==NULL){
            pointer->left = new node;
            pointer->left->value = value;
            updateHeight(root);
            bool Balanced = true;
        node *first = searchParent(pointer->left, value);
        
        while(first !=root){
          Balanced = ifBalanced(first);
          if(Balanced==false){
            break;
          }first = searchParent(first, first->value);
        }


        //cases where first ends up in a node different from root;
        while(ifBalanced(first)==false){
            node* pursuer = first;
            node* previous = searchParent(pursuer, pursuer->value);
            node* detector;
            int drh;
            int dlh;
            if(pursuer->left==NULL){
                dlh = -1;
            }else{
                dlh= pursuer->left->height;
            }
            if(pursuer->right==NULL){
                drh = -1;
            }else{
                drh= pursuer->right->height;
            }
            if(drh>dlh){
              detector = pursuer->right;
            }else{
              detector = pursuer->left;
            }
            
              int temp = root->value;
              int pr, pl, dr, dl;
              if(pursuer->right==NULL){
                pr=-1;
              }else{
                pr = pursuer->right->height;
              }
              if(pursuer->left==NULL){
                pl=-1;
              }else{
                pl= pursuer->left->height;
              }
              if(detector->right==NULL){
                dr=-1;
              }else{
                dr = detector->right->height;
              }
              if(detector->left==NULL){
                dl=-1;
              }else{
                dl= detector->left->height;
              }

              if(pl>pr){
                if(dr>dl){
                  rightRotation(detector, pursuer);
                  leftRotation(pursuer, previous);
                }else{
                  leftRotation(pursuer, previous);
                }
              }else{
                if(dl>dr){
                  leftRotation(detector, pursuer);
                  rightRotation(pursuer, previous);
                }else{
                  rightRotation(pursuer, previous);
                }
              }
            if(first->value == temp){
              break;
            }else{
              first = searchParent(first, first->value);
            }
        }
        return;
          }else{
            pointer = pointer->left;
          }
        }
      }
      if(value>pointer->value){
        pointer->right = new node;
        pointer->right->value = value;
        updateHeight(root);
        //find the lowest level of unbalanced node.
        bool Balanced = true;
        node *first = searchParent(pointer->right, value);
        
        while(first !=root){
          Balanced = ifBalanced(first);
          if(Balanced==false){
            break;
          }first = searchParent(first, first->value);
        }


        //cases where first ends up in a node different from root;
        while(ifBalanced(first)==false){
            node* pursuer = first;
            node* previous = searchParent(pursuer, pursuer->value);
            node* detector;
            int drh;
            int dlh;
            if(pursuer->left==NULL){
                dlh = -1;
            }else{
                dlh= pursuer->left->height;
            }
            if(pursuer->right==NULL){
                drh = -1;
            }else{
                drh= pursuer->right->height;
            }
            if(drh>dlh){
              detector = pursuer->right;
            }else{
              detector = pursuer->left;
            }
              
              int temp = root->value;
              int pr, pl, dr, dl;
              if(pursuer->right==NULL){
                pr=-1;
              }else{
                pr = pursuer->right->height;
              }
              if(pursuer->left==NULL){
                pl=-1;
              }else{
                pl= pursuer->left->height;
              }
              if(detector->right==NULL){
                dr=-1;
              }else{
                dr = detector->right->height;
              }
              if(detector->left==NULL){
                dl=-1;
              }else{
                dl= detector->left->height;
              }

              if(pl>pr){
                if(dr>dl){
                  rightRotation(detector, pursuer);
                  leftRotation(pursuer, previous);
                }else{
                  leftRotation(pursuer, previous);
                }
              }else{
                if(dl>dr){
                  leftRotation(detector, pursuer);
                  rightRotation(pursuer, previous);
                }else{
                  rightRotation(pursuer, previous);
                }
              }
            if(first->value == temp){
              break;
            }else{
              first = searchParent(first, first->value);
            }
        }
        return;
      }else{
        pointer->left = new node;
        pointer->left->value = value;
        updateHeight(root);
        
        bool Balanced = true;
        node *first = searchParent(pointer->left, value);
        
        while(first !=root){
          Balanced = ifBalanced(first);
          if(Balanced==false){
            break;
          }first = searchParent(first, first->value);
        }

        
        //cases where first ends up in a node different from root;
        while(ifBalanced(first)==false){
            
            node* pursuer = first;
            node* previous = searchParent(pursuer, pursuer->value);
            node* detector;
            int drh;
            int dlh;
            if(pursuer->left==NULL){
                dlh = -1;
            }else{
                dlh= pursuer->left->height;
            }
            if(pursuer->right==NULL){
                drh = -1;
            }else{
                drh= pursuer->right->height;
            }
            if(drh>dlh){
              detector = pursuer->right;
            }else{
              detector = pursuer->left;
            }
            

             
              int temp = root->value;
              int pr, pl, dr, dl;
              if(pursuer->right==NULL){
                pr=-1;
              }else{
                pr = pursuer->right->height;
              }
              if(pursuer->left==NULL){
                pl=-1;
              }else{
                pl= pursuer->left->height;
              }
              if(detector->right==NULL){
                dr=-1;
              }else{
                dr = detector->right->height;
              }
              if(detector->left==NULL){
                dl=-1;
              }else{
                dl= detector->left->height;
              }

              if(pl>pr){
                if(dr>dl){
                  rightRotation(detector, pursuer);
                  leftRotation(pursuer, previous);
                }else{
                  leftRotation(pursuer, previous);
                }
              }else{
                if(dl>dr){
                  leftRotation(detector, pursuer);
                  rightRotation(pursuer, previous);
                }else{
                  rightRotation(pursuer, previous);
                }
              }
            if(first->value == temp){
              break;
            }else{
              first = searchParent(first, first->value);
            }
            
        }
        return;
      }
    }
  }
  



  void inOrder(node* pointer){
    if(root==NULL){
      cout << "nothing to print "<< endl;
    }else{
      if(pointer==NULL){
        return;
      }else{
        
        inOrder(pointer->left);
        cout<< pointer->value << " ";
        inOrder(pointer->right);
      }
    }
  }
  




  int updateHeight(node* root){
    if(root==NULL){
      return -1;
    }else{
      root->height = max(updateHeight(root->left), updateHeight(root->right))+1;
      return root->height;
    }
  }
  
  bool ifBalanced(node *pointer){
    if(root==NULL){
      cout<<"Insert Something First"<<endl;
    }else{
     if(pointer->left!=NULL&&pointer->right!=NULL){
      int difference = abs(pointer->left->height-pointer->right->height);
      if(difference > 1){
        return false;
      }
    }else if(pointer->left==NULL){
        int difference = abs(-1-pointer->right->height);
        if(difference > 1){
          return false;
        }
    }else if(pointer->right==NULL){
        int difference = abs(-1-pointer->left->height);
        if(difference > 1){
          return false;
        } 
    }else{
        return true;
      }
    }
    return true;
  }


     

  




  void rightRotation(node *begin, node* previous){
      node* end = begin->right;
      begin->right = end->left;
      end->left = begin;
      
      if(begin==previous){
        root=end;
      }else{
        if(previous->left->value == begin->value){
          previous->left = end;
        }else{
          previous->right = end;
        }
      }
    
    updateHeight(root);
  }
  void leftRotation(node *begin, node* previous){
    
      node *end = begin->left;
      begin->left= end->right;
      end->right = begin;
      if(begin==previous){
        root=end;
      }else{
        if(previous->left->value == begin->value){
          previous->left = end;
        }else{
          previous->right = end;
        }
      }
      
      updateHeight(root);
      
  }
  node* searchParent(node* pointer, int value){
   node* slow = root;
   node* fast = root;
   while(fast->value != value){
     if(fast->value>value){
       slow = fast;
       fast = fast->left;
     }else{
       slow = fast;
       fast=fast->right;
     }
   }
    return slow;
  }
};

  
int main(){
  vector <int> testSequence;
  Tree* myHeap = new Tree();
  myHeap->insert(89);
  
  myHeap->insert(19);
  
  myHeap->insert(20);

  myHeap->insert(4);
  
  myHeap->insert(23);
  
  myHeap->insert(5);
  
  myHeap->insert(6);
  
  myHeap->insert(7);
  
  myHeap->insert(3);
  
  myHeap->insert(2);
  
  myHeap->insert(1);
  
  myHeap->insert(-50);
  
  myHeap->insert(-100);
  
  myHeap->insert(18);
  
  myHeap->insert(22);
  
  myHeap->insert(55);
  
  myHeap->insert(16);
  
  myHeap->insert(100);
  
  myHeap->insert(90);
  
  myHeap->insert(56);
  
  node* search;
  node* search1 = myHeap->search(55);
  
  myHeap->inOrder(myHeap->root);
  cout<<endl;
  cout<< "Root Value " << myHeap->root->value <<endl;
  cout<< "Root Value " << search1->value <<endl;
  
  cout<< "Root Value " << search1->left->value <<endl;
  cout<< "Root Value " << search1->right->value <<endl;
  
  cout<< search1->height << endl;
  
  return 0;
}
