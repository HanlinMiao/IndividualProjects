#include <iostream>
#include <math.h>
#include <vector>
using namespace std;

class node{
  public:
    int value;
    int height;
    node* left;
    node* right;
    node(){
      value = 0;
      height = 0;
      left = NULL;
      right = NULL;
    }
};

class Tree{
  public:
    node* root;

  Tree(){
    root = NULL;
  }

  node* search(int value){
    if(root==NULL){
      cout<< "There is nothing in the tree" <<endl;
    }else{
      node*leaf = root;
      while(leaf!=NULL){
        if(leaf->value>value){
          leaf = leaf->left;
        }else if(leaf->value<value){
          leaf = leaf->right;
        }else{
          return leaf;
        }
      }if(leaf==NULL){
        return NULL;
      }
    }
    return NULL;
  }

  void insert(int value){
    if(root==NULL){
      root = new node;
      root->value = value;
      root->height = 0;
      return;
    }else if(search(value)!=NULL){
      cout<< "You can not insert a repeated value" << endl;
    }else{
      node* fast;
      node* pointer;
      fast = root;
      pointer = root;
      while(fast!=NULL){
        if(fast->value>value){
          pointer = fast;
          fast = fast->left;
        }else{
          pointer = fast;
          fast = fast->right;
        }
      }
      if(pointer->value > value){
        pointer->left = new node;
        pointer->left->value = value;
        updateHeight(root);
        bool Balanced = true;
        node *first = searchParent(pointer->left, value);
        while(first !=root){
          Balanced = ifBalanced(first);
          if(Balanced==false){
            break;
          }first = searchParent(first, first->value);
        }
        while(ifBalanced(first)==false){
            node* pursuer = first;
            node* previous = searchParent(pursuer, pursuer->value);
            node* detector;
            int drh;
            int dlh;
            if(pursuer->left==NULL){
                dlh = -1;
            }else{
                dlh= pursuer->left->height;
            }
            if(pursuer->right==NULL){
                drh = -1;
            }else{
                drh= pursuer->right->height;
            }
            if(drh>dlh){
              detector = pursuer->right;
            }else{
              detector = pursuer->left;
            }
              
              int temp = root->value;
              int pr, pl, dr, dl;
              if(pursuer->right==NULL){
                pr=-1;
              }else{
                pr = pursuer->right->height;
              }
              if(pursuer->left==NULL){
                pl=-1;
              }else{
                pl= pursuer->left->height;
              }
              if(detector->right==NULL){
                dr=-1;
              }else{
                dr = detector->right->height;
              }
              if(detector->left==NULL){
                dl=-1;
              }else{
                dl= detector->left->height;
              }

              if(pl>pr){
                if(dr>dl){
                  rightRotation(detector, pursuer);
                  leftRotation(pursuer, previous);
                }else{
                  leftRotation(pursuer, previous);
                }
              }else{
                if(dl>dr){
                  leftRotation(detector, pursuer);
                  rightRotation(pursuer, previous);
                }else{
                  rightRotation(pursuer, previous);
                }
              }
            if(first->value == temp){
              break;
            }else{
              first = searchParent(first, first->value);
            }
        }
        return;
      }else{
         pointer->right = new node;
            pointer->right->value = value;
            updateHeight(root);
            bool Balanced = true;
        node *first = searchParent(pointer->right, value);
        
        while(first !=root){
          Balanced = ifBalanced(first);
          if(Balanced==false){
            break;
          }first = searchParent(first, first->value);
        }
        while(ifBalanced(first)==false){
            node* pursuer = first;
            node* previous = searchParent(pursuer, pursuer->value);
            node* detector;
            int drh;
            int dlh;
            if(pursuer->left==NULL){
                dlh = -1;
            }else{
                dlh= pursuer->left->height;
            }
            if(pursuer->right==NULL){
                drh = -1;
            }else{
                drh= pursuer->right->height;
            }
            if(drh>dlh){
              detector = pursuer->right;
            }else{
              detector = pursuer->left;
            }
            
              int temp = root->value;
              int pr, pl, dr, dl;
              if(pursuer->right==NULL){
                pr=-1;
              }else{
                pr = pursuer->right->height;
              }
              if(pursuer->left==NULL){
                pl=-1;
              }else{
                pl= pursuer->left->height;
              }
              if(detector->right==NULL){
                dr=-1;
              }else{
                dr = detector->right->height;
              }
              if(detector->left==NULL){
                dl=-1;
              }else{
                dl= detector->left->height;
              }

              if(pl>pr){
                if(dr>dl){
                  rightRotation(detector, pursuer);
                  leftRotation(pursuer, previous);
                }else{
                  leftRotation(pursuer, previous);
                }
              }else{
                if(dl>dr){
                  leftRotation(detector, pursuer);
                  rightRotation(pursuer, previous);
                }else{
                  rightRotation(pursuer, previous);
                }
              }
            if(first->value == temp){
              break;
            }else{
              first = searchParent(first, first->value);
            }
        }
        return;

      }
  
       
    }
  }

  void deleteNode(int value){
    if(root ==NULL){
      cout<< "Insert something to delete"<< endl;
    }else if(search(value)==NULL){
      cout<< value << " does not exist in the tree." << endl;
    }else{
      node* deletion = search(value);
      node* parent = searchParent(deletion, value);
      
      if(deletion->right == NULL && deletion->left==NULL){
        // Deleted Node is a leaf.
        if(parent->right!= NULL&&parent->right->value==value){
          delete deletion;
          parent->right =NULL;
          updateHeight(root);
        }else{
          delete deletion;
          parent->left= NULL;
          updateHeight(root);
        }
      }else if(deletion->right!=NULL && deletion->left!=NULL){
        //Deleted Node is a parent of both children.
      }else{
        //Deleted Node is a parent of one child.
         if(parent->right!= NULL&&parent->right->value==value){
           if(deletion->right==NULL){
             parent->right = deletion->left;
           }else{
             parent->right = deletion->right;
           }
          delete deletion;
          updateHeight(root);
        }else{
          if(deletion->right==NULL){
             parent->left = deletion->left;
           }else{
             parent->left = deletion->right;
           }
          delete deletion;
          updateHeight(root);
        }
      }
      
    }
  }
  



  void inOrder(node* pointer){
    if(root==NULL){
      cout << "nothing to print "<< endl;
    }else{
      if(pointer==NULL){
        return;
      }else{
        
        inOrder(pointer->left);
        cout<< pointer->value << " ";
        inOrder(pointer->right);
      }
    }
  }
  




  int updateHeight(node* root){
    if(root==NULL){
      return -1;
    }else{
      root->height = max(updateHeight(root->left), updateHeight(root->right))+1;
      return root->height;
    }
  }
  
  bool ifBalanced(node *pointer){
    if(root==NULL){
      cout<<"Insert Something First"<<endl;
    }else{
     if(pointer->left!=NULL&&pointer->right!=NULL){
      int difference = abs(pointer->left->height-pointer->right->height);
      if(difference > 1){
        return false;
      }
    }else if(pointer->left==NULL){
        int difference = abs(-1-pointer->right->height);
        if(difference > 1){
          return false;
        }
    }else if(pointer->right==NULL){
        int difference = abs(-1-pointer->left->height);
        if(difference > 1){
          return false;
        } 
    }else{
        return true;
      }
    }
    return true;
  }


     

  




  void rightRotation(node *begin, node* previous){
      node* end = begin->right;
      begin->right = end->left;
      end->left = begin;
      
      if(begin==previous){
        root=end;
      }else{
        if(previous->left->value == begin->value){
          previous->left = end;
        }else{
          previous->right = end;
        }
      }
    
    updateHeight(root);
  }
  void leftRotation(node *begin, node* previous){
    
      node *end = begin->left;
      begin->left= end->right;
      end->right = begin;
      if(begin==previous){
        root=end;
      }else{
        if(previous->left->value == begin->value){
          previous->left = end;
        }else{
          previous->right = end;
        }
      }
      
      updateHeight(root);
      
  }
  node* searchParent(node* pointer, int value){
   node* slow = root;
   node* fast = root;
   while(fast->value != value){
     if(fast->value>value){
       slow = fast;
       fast = fast->left;
     }else{
       slow = fast;
       fast=fast->right;
     }
   }
    return slow;
  }
};

  
int main(){
  vector <int> testSequence;
  Tree* myHeap = new Tree();

  myHeap->insert(89);
  myHeap->insert(19);
  myHeap->insert(20);
  myHeap->insert(4);
  myHeap->insert(23);
  myHeap->insert(5);
  myHeap->insert(6);
  myHeap->insert(7);
  myHeap->insert(3);
  myHeap->insert(2);
  myHeap->insert(1);
  myHeap->insert(-50);
  myHeap->insert(-100);
  myHeap->insert(18);
  myHeap->insert(22);
  myHeap->insert(55);
  myHeap->insert(16);
  myHeap->insert(100);
  myHeap->insert(90);
  myHeap->insert(56);
  myHeap->insert(17);
  myHeap->insert(8);
  myHeap->insert(10);
  myHeap->insert(12);
  myHeap->insert(11);
  myHeap->insert(9);
  myHeap->insert(-1);
  myHeap->insert(-2);
  myHeap->insert(-3);
  myHeap->insert(-5);
  myHeap->insert(-6);
  myHeap->insert(-200);
  myHeap->insert(-400);
  myHeap->insert(-10000);
  //myHeap->deleteNode(-10000);
  //myHeap->deleteNode(-400);
  //myHeap->deleteNode(100);
  
  myHeap->inOrder(myHeap->root);
  
  node* search;
  node* search1 = myHeap->search(18);
  
  
  cout<<endl;
  cout<< "Root Value " << myHeap->root->value <<endl;
  cout<< "Root Value " << search1->value <<endl;

  //cout<< "Root Value " << search1->right->value <<endl;
  
  cout<< "Root Value " << search1->left->value <<endl;
  cout<< "Root Value " << search1->right->value <<endl;
  
  cout<< search1->height << endl;
  
  return 0;
}
